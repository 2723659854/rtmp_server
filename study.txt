
hls协议详解
https://blog.csdn.net/qq_41839588/article/details/134093390

## 安装ffmpeg软件
apk add ffmpeg
推流
## 切面间隔 3秒 创建一个索引
ffmpeg -i rtmp://127.0.0.1/a/b -c:v h264 -c:a aac -f hls -hls_time 3 -hls_list_size 0   ./hls/put.m3u8
## 切面间隔 1秒 创建一个索引
ffmpeg -i rtmp://127.0.0.1/a/b -c:v h264 -c:a aac -f hls -hls_time 1 -hls_list_size 0   ./hls/put.m3u8
## 切面间隔 15秒 创建一个索引
ffmpeg -i rtmp://127.0.0.1/a/b -c:v h264 -c:a aac -f hls -hls_time 15 -hls_list_size 0   ./hls/put.m3u8

ffmpeg -i rtmp://127.0.0.1/a/b -c:v h264 -c:a aac -f hls -hls_time 10 -hls_list_size 0   ./a/b.m3u8

==========================================================================================================================
### 下面的命令是推送视频到rtsp服务器
ffmpeg -re -i demo.mp4 -c:v libx264 -preset veryfast -maxrate 1000k -bufsize 1000k -pix_fmt yuv420p -c:a aac -b:a 160k -ar 44100 -ac 2 -f rtsp rtsp://192.168.101.170:5540/live

ffmpeg -re -i demo.mp4 -c:v libx264 -preset veryfast -maxrate 1000k -bufsize 1000k -pix_fmt yuv420p -c:a aac -b:a 160k -ar 44100 -ac 2 -f rtsp rtsp://192.168.101.170:5540/live

ffmpeg -re -i demo.mp4 -c:v libx264 -preset veryfast -maxrate 1000k -bufsize 1000k -pix_fmt yuv420p -c:a aac -b:a 160k -ar 44100 -ac 2 -f rtsp rtsp://192.168.101.170:5540/live

================================================================================================================================================
以下是rtsp协议的详解
https://cloud.tencent.com/developer/article/2020375
------------------------------------------------------
================================================================================================
RTP在端口号1025到65535之间选择一个未使用的偶数UDP端口号，而在同一次会话中的RTCP则使用下一个基数UDP端口号。RTP默认端口号5004，所以RTCP端口号默认为5005。
--------------------------------------------------
关于协议
https://download.csdn.net/blog/column/12325209/121285741
https://blog.csdn.net/m0_73443478/article/details/137231316
https://blog.csdn.net/peng827965012/article/details/130866600
--------------------------------------------------------------
RTSP协议：负责服务器与客户端之间的请求与响应
RTP协议：负责传输媒体数据
RTCP协议：在RTP传输过程中提供传输信息
rtsp承载与rtp和rtcp之上，rtsp并不会发送媒体数据，而是使用rtp协议传输
rtp并没有规定发送方式，可以选择udp发送或者tcp发送
----------------------------------------------------------------
一次基本的RTSP操作过程:
首先，客户端连接到流服务器并发送一个RTSP描述命令（DESCRIBE）。
流服务器通过一个SDP描述来进行反馈，反馈信息包括流数量、媒体类型等信息。
客户端再分析该SDP描述，并为会话中的每一个流发送一个RTSP建立命令(SETUP)，RTSP建立命令告诉服务器客户端用于接收媒体数据的端口。流媒体连接建立完成后，
客户端发送一个播放命令(PLAY)，服务器就开始在UDP上传送媒体流（RTP包）到客户端。在播放过程中客户端还可以向服务器发送命令来控制快进、快退和暂停等。
最后，客户端可发送一个终止命令(TERADOWN)来结束流媒体会话
————————————————
版权声明：本文为博主原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接和本声明。
原文链接：https://blog.csdn.net/m0_73443478/article/details/137231316
-----------------------------------------------------------------------
一篇关于hls协议转换的文章
https://blog.csdn.net/u013898698/article/details/80803201

======================================================
西瓜播放器
https://h5player.bytedance.com/guide/
========================================================================
rtmp 和 flv发送的都是音频帧AudioFrame和视频帧VideoFrame，
数据被推流到服务器，数据立即被分发给客户端，如果是关键帧，会被保存到队列中。每次有新设备
加入进来，首先发送关键帧，然后发送后续帧。
==================================================================
在加入推流的时候，生成播放索引文件m3u8,然后将接收到的aac 和 avc 数据进项编码打包成ts数据包并保存，同时更新索引文件。
当关闭推流的时候，打完最后一个ts包，在索引文件最后打上结束标志，并保存；
https://blog.csdn.net/qq_35044535/article/details/77838282
ts 是直接把aac和avc 加上header然后写入的，可以使用phpbg/mpegts这个包写入数据。
https://www.cnblogs.com/kuliuheng/p/7127770.html
======================================================================
ts 流分析工具 好像没什么卵用，不能用来打开ts文件
https://www.tsreader.com/legacydownloads/index.html
======================================================================================
Transport Stream
ts文件简称
==========================================================================================
关于flv文件的介绍
https://blog.csdn.net/langzi113/article/details/136235808
============================================================================================
hls协议分析
https://blog.csdn.net/m0_37599645/article/details/117135283

================================================================================
音视频帧的时间戳就是dts,解码时间戳
音频帧头包括三部分：
================================
https://www.cnblogs.com/haibindev/archive/2011/11/10/2244442.html
https://www.cnblogs.com/haibindev/archive/2011/12/29/2305712.html
==========================================================================================
mpegts相关中文文档
https://juejin.cn/post/7102476268930596871
https://blog.yasking.org/a/learn-mpeg2-ts.html
https://blog.csdn.net/qq_25333681/article/details/93541962
https://blog.csdn.net/guoyunfei123/article/details/106319893
========================================================================================
首先传输的数据本身就是es流，是被推流设备编码过后的，
当我们接受到rtmp数据包之后，应该将es数据提取出来，然后封装成pes数据包，然后将pes数据包封装成ts数据包。
===================================================
在网络通信协议当中，通常会使用到位运算，
这样做的好处是：
1，压缩数据，比如是或者否，如果用字节来表示，那么至少要占用一个字节，如果用bit来表示，那么只需要占用一个bit就行了
2，使用位运算，可以提升计算速度，加入用字节来表示数据，那么需要先将字节转换为bit，然后再计算，但是直接使用位运算，就不需要转换，而是可以直接计算的
3，在网络传输中，体积更小，占用更少的宽带。
==============================================================================================
mpeg2 编码和解码
https://blog.csdn.net/houxiaoni01/article/details/99831303
音视频相关书单
https://zhuanlan.zhihu.com/p/427316939
ffmpeg相关讲解
https://ffmpeg.xianwaizhiyin.net/
======================================================
本项目安装了一个phpbg/mpegts扩展包，这个扩展就是个垃圾，只能简单分析mpegts，不能写入（分析其实直接用fread读取出来就行了，根本不需要写一个包）。
但凡了解过mpegts格式，还需要这个包吗，根本用不上。之所以安装这个扩展，就是觉得这个扩展
写的这么烂，挂出来让大家看看。
=============================================
图像的存储方式：比如一张图片有100个像素，每一个像素占8个bit。那么按照从左下角到右上角的顺序挨个像素存储数据，每一个像素里面存储了颜色rgb信息。
然后解析器，按照顺序读取出来后，按照顺序渲染颜色就行了。

============================================
- mpegts https://www.cnblogs.com/moonwalk/p/16200434.html
  国内网友总结的资料
  =====================================================================================================================

  IDR（Instantaneous Decoder Refresh）帧是 H.264 和 H.265 视频编码标准中的一种特殊类型的 I 帧。IDR 帧具有一些独特的特性，使其在视频编码和解码过程中非常重要。

  特性和作用
  完全自包含：

  与普通 I 帧一样，IDR 帧也是完全自包含的，可以独立于其他帧进行解码。它不依赖前后的任何帧。
  刷新解码器状态：

  当解码器遇到一个 IDR 帧时，它会刷新其状态。这意味着在 IDR 帧之前的所有帧对解码器的影响都会被清除。
  这有助于防止错误传播，因为所有后续帧都不会参考 IDR 帧之前的帧。
  开始一个新的 GOP：

  IDR 帧通常标志着一个新的 GOP 的开始。所有在 IDR 帧之前的帧都不会被后续帧引用。
  这使得在需要进行快速随机访问（如跳转到视频的特定位置）时非常有用，因为从 IDR 帧开始的 GOP 可以独立解码。
  应用场景
  视频编辑：

  IDR 帧允许视频编辑软件在某些位置进行切割和拼接，而不会引入解码错误或图像失真。
  流媒体和广播：

  在流媒体和广播应用中，IDR 帧有助于提高错误恢复能力。由于 IDR 帧后面的帧不依赖于前面的帧，解码器可以从 IDR 帧开始重新同步。
  随机访问和跳转：

  IDR 帧使得视频播放器可以快速跳转到视频的任意位置，而不必依赖于之前的帧，这对于用户体验非常重要。
  总结
  IDR 帧在视频编码中扮演着关键角色，提供了刷新解码器状态、防止错误传播和支持快速随机访问等功能。它们是 H.264 和 H.265 编码标准中确保视频质量和可靠性的重要工具。

 ==========================================================================================================================

 在 H.264 编码标准中，GOP 结构（Group of Pictures）定义了视频帧的组织方式，特别是关键帧（I 帧）和非关键帧（如 P 帧和 B 帧）的排列方式。了解 GOP 结构对于视频编码和传输至关重要，因为它直接影响视频质量、压缩效率和错误恢复能力。

 GOP 结构 (GOP Structure)
 Period I (周期 I)：

 在这种结构中，GOP 中的第一帧是 I 帧（关键帧），接下来的若干帧是 P 帧（预测帧）或 B 帧（双向预测帧）。
 I 帧是自包含的，不依赖其他帧进行解码。
 P 帧依赖前面的 I 帧或其他 P 帧进行解码。
 B 帧依赖前后的 I 帧或 P 帧进行解码。
 GOP 结束后，新的 GOP 又以 I 帧开始。
 优点：

 简单且广泛使用，适用于大多数视频编码应用。
 周期性的 I 帧有助于提高错误恢复能力和寻址能力。
 缺点：

 I 帧的引入增加了比特率，因为 I 帧占用的比特数较多。
 GDR (Gradual Decoder Refresh)：

 GDR 是一种逐步刷新解码器的方法，不像传统的周期 I 帧那样一次性引入一个完整的 I 帧。
 在这种结构中，逐步引入新的 I 块（Intra Block），逐步替换掉 P 帧中的块。这种方式逐渐刷新整个图像，而不是一次性完成。
 这种方法有助于减少突然增加的比特率，同时提供类似于 I 帧的错误恢复能力。
 优点：

 更均匀的比特率分布，避免了 I 帧带来的比特率峰值。
 提高了错误恢复能力，因为逐步刷新减少了整个图像因错误而受到影响的可能性。
 缺点：

 实现更为复杂，编码和解码过程可能需要更多计算资源。
 这句话的含义
 “使用 H.264 编码标准时，GOP structure 可选，为 Period I 或者 GDR。”意思是：

 在使用 H.264 编码视频时，可以选择两种不同的 GOP 结构：

 Period I：传统的周期性 I 帧结构，定期引入 I 帧。
 GDR：逐步刷新解码器的结构，通过逐步替换 P 帧中的块来刷新图像。
 这两种结构各有优缺点，选择哪种结构取决于具体的应用需求，如比特率管理、错误恢复能力和计算资源等。
 =======================================================================================
 使用 H.264 编码标准时，Gop structure 可选，为 Period I 或者 GDR。
 如果是 Period Ⅰ，要求每个 I 帧为 IDR 帧，若不符合要求，则不保证图传能够从丢包错误中正确恢复。在发送完 SPS/PPS 之后，需要立马传输Ⅰ帧的流，
 然后再传输 AUD，在 SPS/PPS 和 slice 之间无 AUD 信息。Period Ⅰ结构中，建议一秒一个 IDR。
 如果为 GDR，在每个 GDR 刷新帧需要传输 sps/pps。
 ====================================================================================================================

 我们通用的USB接口，也有自己的USB协议。每一个节点有自己的名字和作用。

 USB（Universal Serial Bus，通用串行总线）是一种连接计算机和外部设备的标准接口协议，确实有自己的通信协议。USB 协议定义了数据传输的方式、电气特性、插拔规范以及设备之间的通信规则，使得不同厂商生产的设备可以在各种操作系统中无缝连接和使用。

 主要特点和组成部分：
 物理接口：

 USB 使用四根线（VCC、GND、数据+、数据-）作为基本连接，通过标准化的接口插头和插孔进行连接。这种设计使得 USB 设备可以轻松地插拔和热插拔，而无需关闭计算机或设备。
 数据传输协议：

 USB 定义了数据传输的不同速率和传输模式，如低速（1.5 Mbps）、全速（12 Mbps）、高速（480 Mbps）、超高速（5 Gbps 和 10 Gbps）等。每种速率有其特定的数据传输协议和带宽要求。
 通信协议：

 USB 设备与主机之间的通信遵循一套标准化的通信协议，包括数据包的格式、帧结构、错误检测和纠正机制等。这些协议确保了设备之间的互操作性和数据传输的可靠性。
 电源规范：

 USB 接口不仅用于数据传输，还提供了标准化的电源规范。根据设备的功耗需求，USB 接口可以提供不同的电流和电压。
 设备分类：

 USB 协议将设备分为多个类别（如存储设备、键盘鼠标、音频设备、视频设备等），每个类别都有自己的通信协议和特定功能描述符。
 USB 协议的演变：
 USB 1.x：最初的 USB 标准，包括低速和全速模式。
 USB 2.0：引入了高速模式，传输速率达到 480 Mbps。
 USB 3.x：进一步提高了传输速率，引入了超高速模式（5 Gbps 和 10 Gbps）。
 USB4：整合了 Thunderbolt 技术，提供更高的速度和带宽。
 应用领域：
 USB 协议广泛应用于各种设备，包括外部存储、打印机、键盘、鼠标、摄像头、音频设备、移动设备、电子设备等。几乎所有现代计算机和消费电子设备都支持 USB 接口。
 总之，USB 协议作为一种通用、标准化的接口协议，为设备之间的连接和数据交换提供了可靠的解决方案，极大地促进了各种设备的互联和互操作性。
 =========================================================================================================================
 是的，USB 存储设备内部通常包含一颗专门的控制器芯片（Controller Chip），负责处理存储设备的业务。这个控制器芯片起着关键的作用，管理设备的存储、
 数据传输、文件系统以及与主机的通信。

 控制器芯片的功能：
 USB 接口管理：

 控制器芯片负责与主机的 USB 接口通信，处理主机发来的命令和数据请求。
 存储管理：

 管理存储设备中的存储单元（如闪存芯片），包括数据的读取、写入、擦除以及坏块管理。
 文件系统支持：

 控制器芯片通常支持多种文件系统，如 FAT32、exFAT、NTFS 等，以便在不同的操作系统上进行数据存储和读取。
 错误检测与修复：

 提供数据完整性检测和错误修复功能，确保存储数据的可靠性和稳定性。
 性能优化：

 控制器芯片可能包含缓存管理和数据压缩算法，以提升数据读写速度和存储效率。
 电源管理：

 负责管理 USB 设备的电源供应，确保在不同的使用情境下能够有效地管理电力消耗。
 结构和设计：
 控制器芯片通常由 CPU、存储控制逻辑、USB 控制器、电源管理单元等组成。它们的设计目标是在尽可能小的物理空间内提供高性能和低功耗的解决方案。
 应用场景：
 USB 存储设备，如闪存驱动器（USB Flash Drive）和移动硬盘（Portable Hard Drive），都依赖于这些控制器芯片来实现高速、可靠的数据存储和传输功能。
 总之，控制器芯片在 USB 存储设备中扮演着关键角色，确保设备能够有效地与主机通信并管理存储，以实现高性能、高可靠性和良好的用户体验。
 ========================================================================================================================

